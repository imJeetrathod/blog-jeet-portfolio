---
title: "Using Gemini CLI as my default AI entry point"
description: "Notes from setting up Gemini CLI and slowly adopting it in my terminal. Not a tutorial, just observations on why it stuck."
date: 2025-12-15
category: ai
tags: [ai, gemini, cli, terminal, devtools]
---
---

## Why I wanted AI in my terminal

Most of my AI usage started in browser tabs.  
That worked fine, but it always felt slightly detached from what I was actually doing.

My terminal is already where I live: git, logs, scripts, quick experiments. Switching context just to ask a question felt unnecessary. When Gemini CLI showed up, I mostly wanted to see if AI could feel *native* there instead of bolted on.

This wasn’t about replacing anything. Just reducing friction.

---

## What I actually set up

I kept the setup intentionally boring.

No automation.  
No fancy shell integrations.  
Just the CLI available when I needed it.

I wanted to answer one question first:  
Would I naturally reach for it while working, or forget it existed?

---

## The first few days of usage

Early usage was very lightweight.

I asked it to:
- Explain error output I just saw
- Sanity-check small code snippets
- Reword things before committing or sharing

Nothing impressive on paper. But the important part was that I didn’t have to *leave* my flow to do any of this.

That alone changed how often I used it.

---

## Why the CLI form factor matters (for me)

The value wasn’t Gemini being smarter than other tools.  
It was Gemini being **closer**.

Running a command and immediately asking about its output feels different than copying text into a browser. The latency isn’t just technical — it’s mental.

Using the CLI feels like continuing the same thought instead of starting a new one.

---

## How it fits into my daily workflow now

After a week or two, Gemini CLI became something I use without thinking about it.

Mostly for:
- Quick clarifications while debugging
- Summarizing noisy logs
- Getting unstuck without opening more tabs

It doesn’t try to be my IDE.  
It doesn’t try to be an agent.

It’s just there when I need a second brain.

---

## Where it still feels limited

There are clear limits.

It doesn’t understand my whole codebase.  
It doesn’t proactively suggest changes.  
Sometimes responses are generic.

And that’s fine.

I don’t want every tool to be “intelligent.” I want it to be *available*. The CLI version succeeds more because of where it lives than what it can do.

---

## Why this feels like a real shift

AI tools used to feel like destinations.  
Now they’re starting to feel like interfaces.

Gemini CLI didn’t change how I code.  
It changed how often I ask questions while coding.

That’s a subtle difference, but it adds up over time.

---

## Final notes

This isn’t a recommendation post.

But if your terminal is already your primary workspace, Gemini CLI is worth trying — not because it’s powerful on paper, but because it removes just enough friction to matter.

That was the part I didn’t expect.
